from sqlalchemy.orm import Session
from typing import Optional, Any, TypeVar, Generic
from pydantic import BaseModel
from sqlalchemy.exc import IntegrityError, OperationalError, SQLAlchemyError

T = TypeVar('T')

class BaseRepository(Generic[T]): # Generic variable will take the value of a model
    def __init__(self, model):
        self.model = model # self.model now stores model reference and will be used in all methods

    def get(self, db:Session, filters: Optional[BaseModel] = None) -> Optional[T]:
        query = db.query(self.model)
        filter_data = filters.model_dump(exclude_unset=True) # Pydantic v2 method to convert model to dictionary

        for field, value in filter_data.items():
            if value is not None and hasattr(self.model, field): # If field's value is not null and that field is
                                                                 # present in self.model
                                                                 # The model in our case is Users and if the filter
                                                                 # had id as field then the condition is valid
                                                                 # But if it had location then it would have been
                                                                 # invalid since location is not present in self.model
                query = query.filter(getattr(self.model, field) == value)

        return query.all()

    def create(self, db:Session, obj_in: Any) -> T: # obj_in can be any input object (Pydantic v2, SQLAlchemy object, Plain dict)
        if isinstance(obj_in, self.model):
            db_obj = obj_in  # Already a SQLAlchemy object, no conversion needed
        elif isinstance(obj_in, BaseModel):
            db_obj = self.model(**obj_in.model_dump())  # Pydantic v2, we convert it to a dictionary using model_dump()
        elif isinstance(obj_in, dict):
            db_obj = self.model(**obj_in)  # Plain dict, we directly unpack it into the model constructor with **obj_in
        else:
            raise ValueError("Unsupported input type for create()")

        db.add(db_obj) # Adds the object to the current SQLAlchemy session, marking it for insertion into the database.

        try:
            db.commit() # Saves the object to the database.
            db.refresh(db_obj) # Reloads the object from the database, including autogenerated fields like id or created_at.
        except (IntegrityError, OperationalError, SQLAlchemyError):
            db.rollback() # Reverts the session if an error occurs to avoid leaving it in an invalid state.
            raise

        return db_obj